package com.example.ponggame;

import java.util.Random;
import android.os.Bundle;
import android.app.Activity;
import android.support.v4.view.MotionEventCompat;
import android.util.Log;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.graphics.Rect;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.view.View.OnTouchListener;
import android.view.Window;
import android.view.WindowManager;

public class PongGame extends Activity implements OnTouchListener
{
 // All global objects needed
	FastRenderView renderView;
	MovingObjRect mRectOne;
	Rect moveRect;

	// All global variables needed
	int playerOnePoints;
	int playerTwoPoints;
	// String playerOO;
	// String playerTT;
	int curPointPosXtwo;
	int curPointPosYtwo;
	int curPointPosXone;
	int curPointPosYone;
	float deltaTime;
	
	//RectPos
	int rectTop;
	int rectBottom;
	int rectRight;
	int rectLeft;
	int pastTop;
	int pastBottom;
	int pastRight;
	int pastLeft;
	
	public void onCreate( Bundle savedInstanceState )
	{
		super.onCreate( savedInstanceState );
 
		// Initilizing things for the MovingObjRect Class
		Log.d("KevinMsss", "MoveObjRect ");
		playerOnePoints = 0;
		playerTwoPoints = 0;
		// playerOO = playerOnePoints.toString();
		// playerTT = playerTwoPoints.toString();
		moveRect = new Rect( 375, 615, 425, 665 );
		mRectOne = new MovingObjRect( 2, true );
		mRectOne.startDir();
		rectLeft = 375;
		rectBottom = 615;
		rectRight = 425;
		rectTop = 665;
 
		// Initilizing starter variables for the paddles
		curPointPosXone = 400;
		curPointPosYone = 1180;
		curPointPosXtwo = 400;
		curPointPosYtwo = 25;
		
		// Requesting the fullscreen for the activity
		Log.d("KevinMess", "FullScreen");
		requestWindowFeature( Window.FEATURE_NO_TITLE );
		getWindow().setFlags( WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN );
 
		// Starting up the rendering
		Log.d("KevinMess", "OnCreate render");
		renderView = new FastRenderView( this );
		renderView.setOnTouchListener( this );
		renderView.run();
		setContentView( renderView );
		
		//LogFiles
		Log.d("KevinMess", "OnCreate !");
	}

	public boolean onTouch( View v, MotionEvent event )
	{
		// Initilizing some varibles for multi-touch
		int halfHeight = renderView.getHeight() / 2;
		int maxCount = event.getPointerCount();
		int action = MotionEventCompat.getActionMasked( event );
		Log.d("KevinApp", "OnTouch: " + String.valueOf( action ));
		for ( int i = 0; i < maxCount; i++ )
		{
			// int mActivePointerId = event.getPointerId( i );
			// int pointerIndex = event.findPointerIndex( mActivePointerId );
			// int index = MotionEventCompat.getActionIndex( event );
   
			// Reacting to the finger taps
			switch( action )
			{
				case MotionEvent.ACTION_DOWN:
				case MotionEvent.ACTION_POINTER_DOWN:
				case MotionEvent.ACTION_MOVE:
					if ( MotionEventCompat.getY( event, i ) < halfHeight )
					{
						curPointPosXtwo = (int) MotionEventCompat.getX( event, i );
						// curPointPosYtwo = (int) MotionEventCompat.getY( event, i );
					}
					if ( MotionEventCompat.getY( event, i ) > halfHeight )
					{
						curPointPosXone = (int) MotionEventCompat.getX( event, i );
						// curPointPosYone = (int) MotionEventCompat.getY( event, i );
					}
					break;
			}
		}	
		return true;
	}

	protected void onResume()
	{
		Log.d("KevinMess", "OnResume");
		super.onResume();
		renderView.resume();
	}

	protected void onPause()
	{
		Log.d("KevinMess", "OnPause");
		super.onPause();
		renderView.pause();
	}	  

	class FastRenderView extends SurfaceView implements Runnable 
	{
		Thread renderThread = null;
		SurfaceHolder holder;
		volatile boolean running = false;
		Paint paint;
 
		public FastRenderView( Context context )
		{
			super( context );
			holder = getHolder();
			paint = new Paint();
			Log.d("KevinMess", "Consructor works!");
		}
 
		public void resume()
		{
			Log.d("KevinMess", "FASTresume");
			running = true;
			renderThread = new Thread( this );
			renderThread.start();
		}	
 
		public void run()
		{
			int looper = 0;
			Log.d("KevinMess", "B loop");
			long startTime = System.nanoTime();
			while( running )
			{
				Log.d("KevinMess", "Loop!");
				// Setting up the time
				deltaTime = ( System.nanoTime() - startTime ) * 1000000000.0f;
				startTime = System.nanoTime();
     
				// Starting the main rendering part of the thread
				if( !holder.getSurface().isValid() )
					continue;
				Canvas canvas = holder.lockCanvas();
				canvas.drawRGB( 255, 255, 255 );
				paint.setStyle( Style.FILL );
				int width = canvas.getWidth();
				int height = canvas.getHeight();
				paint.setColor( Color.RED );
				canvas.drawLine( 0, height / 2, width, height / 2, paint );
     
				// Moving Rectangle block
				paint.setColor( Color.BLUE );
				canvas.drawRect( rectLeft, rectBottom, rectRight, rectTop, paint );
				//if ( looper > 1 )
					//canvas.drawRect( pastLeft, pastBottom, pastRight, pastTop, paint );
					//mRectOne.DiffuseRect();
				//Debug logs
				Log.d( "RectLeftStat", Integer.toString(rectLeft) );
				Log.d( "RectRightStat", Integer.toString(rectRight) );
				Log.d( "RectBottomStat", Integer.toString(rectBottom) );
				Log.d( "RectTopStat", Integer.toString(rectTop) );
				Log.d( "KevinMess", Float.toString(deltaTime) );
				
				//Draw the paddles onto the canvas
				paint.setColor( Color.BLUE );
				canvas.drawRect( (curPointPosXone - 100), (curPointPosYone - 25), (curPointPosXone + 100), (curPointPosYone + 25), paint );
				// canvas.drawText( playerOO ); 
				paint.setColor( Color.GREEN );
				canvas.drawRect( (curPointPosXtwo - 100), (curPointPosYtwo - 25), (curPointPosXtwo + 100), (curPointPosYtwo + 25), paint );
				// canvas.drawText( playerTT );
     
				// Cleaning and re-orientating
				holder.unlockCanvasAndPost( canvas );
				mRectOne.collisionCheck();
				mRectOne.moveRectNoAccel( deltaTime );
				looper++;
			}
		}
 
		public void pause() 
		{
			Log.d("KevinMess", "renderPause");
			running = false;
			while( true )
			{
				try {
					renderThread.join();
					return;
				} catch ( InterruptedException e ) {
					//retry
				}
			}
		}
	}

	public class MovingObjRect 
	{
		public String direction;
		public int moveRate;
		public boolean moving;
		public MovingObjRect( int moveRate, boolean moving )
		{
			Log.d("KevinMess","MOR");
			this.moveRate = moveRate;
			this.moving = moving;
		}
 
		public void moveRectNoAccel( float passedTime )
		{
			Log.d("KevinMess", "moveRectNoAcccel");
			// Gaining movement per second 
			int deltaMove = (int) (( int ) moveRate * passedTime);
   
			// Direction check and re-posistion block 
			if ( direction == "down" )
				rectTop = rectTop + deltaMove;
				rectBottom = rectBottom + deltaMove;
   
			if ( direction == "up" )
				rectTop = rectTop - deltaMove;
				rectBottom = rectBottom - deltaMove;
   
			if ( direction == "upRight" )  
				rectTop = rectTop - deltaMove;
				rectRight = rectRight + deltaMove;
				rectLeft = rectLeft + deltaMove;
				rectBottom = rectBottom + deltaMove;
   
			if ( direction == "upLeft" )
				rectTop = rectTop - deltaMove;
				rectRight = rectRight - deltaMove;
				rectLeft = rectLeft - deltaMove;
				rectBottom = rectBottom - deltaMove;
     
			if ( direction == "downRight" )
				rectTop = rectTop + deltaMove;
				rectRight = rectRight + deltaMove;
				rectLeft = rectLeft + deltaMove;
				rectBottom = rectBottom + deltaMove;
   
			if ( direction == "downLeft" )
				rectTop = rectTop + deltaMove;
				rectRight = rectRight - deltaMove;
				rectLeft = rectLeft - deltaMove;
				rectBottom = rectBottom + deltaMove;
		}
 
		public void moveRectWithAccel( int passedTime )
		{
			// update placement of rectangle when called depending on the deltaTime
			// also look for direction variables and state
			// do the added calculation on acceleration
		}
 
		public void collisionCheck()
		{
			Log.d("KevinMess", "collCheck");
			// Checking if the moving Rectangle has hit the top of the screen and rewarding points to the second player
			if ( rectTop <= 0 )
				playerTwoPoints = playerTwoPoints++;
				// playerTT = ( String ) playerTwoPoints;
				// create function to restart the moveRect
   
			// Checking for if the paddle has been hit
			if ( rectTop <=  50 ) 
				direction = "down";
     
			// Checking if the movingRectangle has hit the bottom of the screen and rewarding points to first player  
			if ( rectBottom >= 1280 )
				playerOnePoints = playerOnePoints++;
				// playerOO = ( String ) playerOnePoints;
				// Create a function to restart the moveRect
     
			// Checking for if the bottom paddle has been hit.  
			if ( rectBottom >= 1230 )
				direction = "up";
     
			// Checking for the hitting of the sides of the screen and changing the direction  
			if ( rectLeft <= 0 && direction == "up")
				direction = "upRight";
			if ( rectRight >= 800 && direction == "up" )
				direction = "upLeft";
			if ( rectLeft <= 0 && direction == "down" )
				direction = "downRight";
			if ( rectLeft >= 800 && direction == "down" )
				direction = "downLeft";
		}
		
		public void startDir()
		{
			String[] dirList = { "upLeft", "upRight", "up", "downLeft", "downRight", "down" };
			Random r = new Random();
			direction = dirList[ r.nextInt( dirList.length ) ];
			Log.d("directions", direction);
		}
		
		public void DiffuseRect()
		{
			rectTop = pastTop;
			rectBottom = pastBottom;
			rectLeft = pastLeft;
			rectRight = pastRight;
		}
	}
}
