package com.example.ponggame;

import java.util.Random;
import android.os.Bundle;
import android.app.Activity;
import android.support.v4.view.MotionEventCompat;
import android.util.Log;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.graphics.Rect;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.view.View.OnTouchListener;
import android.view.Window;
import android.view.WindowManager;

public class PongGame extends Activity implements OnTouchListener
{
 // All global objects needed
	FastRenderView renderView;
	MovingObjRect mRectOne;
	Rect moveRect;

	// All global variables needed
	int playerOnePoints;
	int playerTwoPoints;
	// String playerOO;
	// String playerTT;
	int curPointPosXtwo;
	int curPointPosYtwo;
	int curPointPosXone;
	int curPointPosYone;
	float deltaTime;

	public void onCreate( Bundle savedInstanceState )
	{
		super.onCreate( savedInstanceState );
 
		// Initilizing things for the MovingObjRect Class
		playerOnePoints = 0;
		playerTwoPoints = 0;
		// playerOO = playerOnePoints.toString();
		// playerTT = playerTwoPoints.toString();
		moveRect = new Rect( 375, 615, 425, 665 );
		mRectOne = new MovingObjRect( 2, true );
		mRectOne.startDir();
 
		// Initilizing starter variables for the paddles
		curPointPosXone = 400;
		curPointPosYone = 1180;
		curPointPosXtwo = 400;
		curPointPosYtwo = 25;
 
		// Requesting the fullscreen for the activity 
		requestWindowFeature( Window.FEATURE_NO_TITLE );
		getWindow().setFlags( WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN );
 
		// Starting up the rendering
		renderView = new FastRenderView( this );
		renderView.setOnTouchListener( this );
		setContentView( renderView );
		
		//LogFiles
		Log.d("KevinMess", "OnCreate !");
	}

	public boolean onTouch( View v, MotionEvent event )
	{
		// Initilizing some varibles for multi-touch
		int halfHeight = renderView.getHeight() / 2;
		int maxCount = event.getPointerCount();
		int action = MotionEventCompat.getActionMasked( event );
		Log.d("KevinApp", "OnTouch: " + String.valueOf( action ));
		for ( int i = 0; i < maxCount; i++ )
		{
			// int mActivePointerId = event.getPointerId( i );
			// int pointerIndex = event.findPointerIndex( mActivePointerId );
			// int index = MotionEventCompat.getActionIndex( event );
   
			// Reacting to the finger taps
			switch( action )
			{
				case MotionEvent.ACTION_DOWN:
				case MotionEvent.ACTION_POINTER_DOWN:
				case MotionEvent.ACTION_MOVE:
					if ( MotionEventCompat.getY( event, i ) < halfHeight )
					{
						curPointPosXtwo = (int) MotionEventCompat.getX( event, i );
						curPointPosYtwo = (int) MotionEventCompat.getY( event, i );
					}
					if ( MotionEventCompat.getY( event, i ) > halfHeight )
					{
						curPointPosXone = (int) MotionEventCompat.getX( event, i );
						// curPointPosYone = (int) MotionEventCompat.getY( event, i );
					}
					break;
			}
		}	
		return true;
	}

	protected void onResume()
	{
		super.onResume();
		renderView.resume();
	}

	protected void onPause()
	{
		super.onPause();
		renderView.pause();
	}	  

	class FastRenderView extends SurfaceView implements Runnable 
	{
		Thread renderThread = null;
		SurfaceHolder holder;
		volatile boolean running = false;
		Paint paint;
 
		public FastRenderView( Context context )
		{
			super( context );
			holder = getHolder();
			paint = new Paint();
			Log.d("KevinMess", "Consructor works!");
		}
 
		public void resume()
		{
			running = true;
			renderThread = new Thread( this );
			renderThread.start();
		}	
 
		public void run()
		{
			Log.d("KevinMess", "B loop");
			long startTime = System.nanoTime();
			while( running )
			{
				Log.d("KevinMess", "Loop!");
				// Setting up the time
				deltaTime = ( System.nanoTime() - startTime ) / 1000000000.0f;
				startTime = System.nanoTime();
     
				// Starting the main rendering part of the thread
				if( !holder.getSurface().isValid() )
					continue;
				Canvas canvas = holder.lockCanvas();
				canvas.drawRGB( 255, 255, 255 );
				paint.setStyle( Style.FILL );
				int width = canvas.getWidth();
				int height = canvas.getWidth();
				paint.setColor( Color.RED );
				canvas.drawLine( (width - width), height / 2, width, height / 2, paint );
     
				// Moving Rectangle block
				paint.setColor( Color.BLUE );
				canvas.drawRect( moveRect, paint ) ;
     
				//Draw the paddles onto the canvas
				paint.setColor( Color.BLUE );
				canvas.drawRect( (curPointPosXone - 100), (curPointPosYone - 25), (curPointPosXone + 100), (curPointPosYone + 25), paint );
				// canvas.drawText( playerOO ); 
				paint.setColor( Color.GREEN );
				canvas.drawRect( (curPointPosXtwo - 100), (curPointPosYtwo - 25), (curPointPosXtwo + 100), (curPointPosYtwo + 25), paint );
				// canvas.drawText( playerTT );
     
				// Cleaning and re-orientating
				holder.unlockCanvasAndPost( canvas );
				mRectOne.collisionCheck();
				mRectOne.moveRectNoAccel( deltaTime );
			}
		}
 
		public void pause() 
		{
			running = false;
			while( true )
			{
				try {
					renderThread.join();
					return;
				} catch ( InterruptedException e ) {
					//retry
				}
			}
		}
	}

	public class MovingObjRect 
	{
		public String direction;
		public int moveRate;
		public boolean moving;
		public MovingObjRect( int moveRate, boolean moving )
		{
			Log.d("KevinMess","MOR");
			this.moveRate = moveRate;
			this.moving = moving;
		}
 
		public void moveRectNoAccel( float passedTime )
		{
			// Gaining movement per second 
			int deltaMove = (int) (( int ) moveRate * passedTime);
   
			// Direction check and re-posistion block 
			if ( direction == "down" )
				moveRect.top = moveRect.top + deltaMove;
				moveRect.bottom = moveRect.bottom + deltaMove;
   
			if ( direction == "up" )
				moveRect.top = moveRect.top - deltaMove;
				moveRect.bottom = moveRect.bottom - deltaMove;
   
			if ( direction == "upRight" )  
				moveRect.top = moveRect.top - deltaMove;
				moveRect.right = moveRect.right + deltaMove;
				moveRect.left = moveRect.left + deltaMove;
				moveRect.bottom = moveRect.bottom + deltaMove;
   
			if ( direction == "upLeft" )
				moveRect.top = moveRect.top - deltaMove;
				moveRect.right = moveRect.right - deltaMove;
				moveRect.left = moveRect.left - deltaMove;
				moveRect.bottom = moveRect.bottom - deltaMove;
     
			if ( direction == "downRight" )
				moveRect.top = moveRect.top + deltaMove;
				moveRect.right = moveRect.right + deltaMove;
				moveRect.left = moveRect.left + deltaMove;
				moveRect.bottom = moveRect.bottom + deltaMove;
   
			if ( direction == "downLeft" )
				moveRect.top = moveRect.top + deltaMove;
				moveRect.right = moveRect.right - deltaMove;
				moveRect.left = moveRect.left - deltaMove;
				moveRect.bottom = moveRect.bottom + deltaMove;
		}
 
		public void moveRectWithAccel( int passedTime )
		{
			// update placement of rectangle when called depending on the deltaTime
			// also look for direction variables and state
			// do the added calculation on acceleration
		}
 
		public void collisionCheck()
		{
			// Checking if the moving Rectangle has hit the top of the screen and rewarding points to the second player
			if ( moveRect.top <= 0 )
				playerTwoPoints = playerTwoPoints++;
				// playerTT = ( String ) playerTwoPoints;
				// create function to restart the moveRect
   
			// Checking for if the paddle has been hit
			if ( moveRect.top <=  50 ) 
				direction = "down";
     
			// Checking if the movingRectangle has hit the bottom of the screen and rewarding points to first player  
			if ( moveRect.bottom >= 1280 )
				playerOnePoints = playerOnePoints++;
				// playerOO = ( String ) playerOnePoints;
				// Create a function to restart the moveRect
     
			// Checking for if the bottom paddle has been hit.  
			if ( moveRect.bottom >= 1230 )
				direction = "up";
     
			// Checking for the hitting of the sides of the screen and changing the direction  
			if ( moveRect.left <= 0 && direction == "up")
				direction = "upRight";
			if ( moveRect.right >= 800 && direction == "up" )
				direction = "upLeft";
			if ( moveRect.left <= 0 && direction == "down" )
				direction = "downRight";
			if ( moveRect.right >= 800 && direction == "down" )
				direction = "downLeft";
		}
		
		public void startDir()
		{
			Random randomGen;
			randomGen = new Random();
			String[] directArray;
			directArray = new String[5];
			directArray[0] = "upLeft";
			directArray[1] = "upRight";
			directArray[2] = "downLeft";
			directArray[3] = "downRight";
			directArray[4] = "down";
			directArray[5] = "up";
			int ranIndex; 
			ranIndex = randomGen.nextInt(directArray.length);
			direction = directArray[ranIndex];
			Log.d("KevinMess", "DirStart");
		}
	}
}
